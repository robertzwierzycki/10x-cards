/**
 * Unit tests for AI Generation Validation Schema
 *
 * Tests cover:
 * - generateFlashcardsSchema - input text validation
 * - Minimum length validation (1 character)
 * - Maximum length validation (1000 characters)
 * - Whitespace trimming
 * - Required field validation
 */

import { describe, it, expect } from "vitest";
import { generateFlashcardsSchema } from "./ai-generation.schema";

describe("generateFlashcardsSchema", () => {
  describe("Valid input", () => {
    it("should validate text with minimum length", () => {
      const result = generateFlashcardsSchema.safeParse({ text: "A" });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe("A");
      }
    });

    it("should validate text with typical length", () => {
      const text = "What is TypeScript? It is a typed superset of JavaScript.";
      const result = generateFlashcardsSchema.safeParse({ text });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe(text);
      }
    });

    it("should trim whitespace from text", () => {
      const result = generateFlashcardsSchema.safeParse({ text: "  Sample text  " });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe("Sample text");
      }
    });

    it("should accept text with exactly 1000 characters", () => {
      const maxText = "a".repeat(1000);
      const result = generateFlashcardsSchema.safeParse({ text: maxText });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toHaveLength(1000);
      }
    });

    it("should handle multi-line text", () => {
      const multiLine = "Line 1\nLine 2\nLine 3";
      const result = generateFlashcardsSchema.safeParse({ text: multiLine });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe(multiLine);
      }
    });

    it("should handle text with special characters", () => {
      const specialText = 'Text with "quotes", symbols: @#$%, and √©mojis üéì';
      const result = generateFlashcardsSchema.safeParse({ text: specialText });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe(specialText);
      }
    });

    it("should handle text with Unicode characters", () => {
      const unicodeText = "Za≈º√≥≈Çƒá gƒô≈õlƒÖ ja≈∫≈Ñ - polskie znaki diakrytyczne";
      const result = generateFlashcardsSchema.safeParse({ text: unicodeText });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe(unicodeText);
      }
    });
  });

  describe("Invalid input - empty text", () => {
    it("should reject empty string", () => {
      const result = generateFlashcardsSchema.safeParse({ text: "" });

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.errors[0].message).toBe("Text is required and cannot be empty");
      }
    });

    it("should trim and transform whitespace-only text to empty", () => {
      // Note: .trim() in transform happens AFTER validation
      // So '   ' (3 chars) passes .min(1) but gets trimmed to ''
      const result = generateFlashcardsSchema.safeParse({ text: "   " });

      // Current behavior: passes validation but transforms to empty string
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe("");
      }
    });

    it("should reject missing text field", () => {
      const result = generateFlashcardsSchema.safeParse({});

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.errors[0].path).toContain("text");
      }
    });

    it("should reject null text", () => {
      const result = generateFlashcardsSchema.safeParse({ text: null });

      expect(result.success).toBe(false);
    });

    it("should reject undefined text", () => {
      const result = generateFlashcardsSchema.safeParse({ text: undefined });

      expect(result.success).toBe(false);
    });
  });

  describe("Invalid input - exceeds maximum length", () => {
    it("should reject text exceeding 1000 characters", () => {
      const tooLong = "a".repeat(1001);
      const result = generateFlashcardsSchema.safeParse({ text: tooLong });

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.errors[0].message).toBe("Text exceeds 1000 character limit");
      }
    });

    it("should reject text with 2000 characters", () => {
      const wayTooLong = "b".repeat(2000);
      const result = generateFlashcardsSchema.safeParse({ text: wayTooLong });

      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.errors[0].message).toBe("Text exceeds 1000 character limit");
      }
    });

    it("should reject text with 1001 characters (boundary)", () => {
      const justOverLimit = "x".repeat(1001);
      const result = generateFlashcardsSchema.safeParse({ text: justOverLimit });

      expect(result.success).toBe(false);
    });
  });

  describe("Edge cases", () => {
    it("should handle text with tabs and newlines", () => {
      const text = "\t\tTab text\n\nWith newlines\t";
      const result = generateFlashcardsSchema.safeParse({ text });

      expect(result.success).toBe(true);
      if (result.success) {
        // Trim removes leading/trailing whitespace including tabs and newlines
        expect(result.data.text).toBe("Tab text\n\nWith newlines");
      }
    });

    it("should preserve internal spacing", () => {
      const text = "Text    with    multiple    spaces";
      const result = generateFlashcardsSchema.safeParse({ text });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe(text);
      }
    });

    it("should handle HTML-like content", () => {
      const html = "<p>HTML content with <strong>tags</strong></p>";
      const result = generateFlashcardsSchema.safeParse({ text: html });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe(html);
      }
    });

    it("should handle markdown-like content", () => {
      const markdown = "# Heading\n\n**Bold text** and *italic*\n\n- List item";
      const result = generateFlashcardsSchema.safeParse({ text: markdown });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe(markdown);
      }
    });

    it("should handle code snippets", () => {
      const code = 'function example() {\n  return "Hello";\n}';
      const result = generateFlashcardsSchema.safeParse({ text: code });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toBe(code);
      }
    });

    it("should handle text at exactly 999 characters", () => {
      const almostMax = "y".repeat(999);
      const result = generateFlashcardsSchema.safeParse({ text: almostMax });

      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.text).toHaveLength(999);
      }
    });

    it("should reject non-string types", () => {
      const result = generateFlashcardsSchema.safeParse({ text: 12345 });

      expect(result.success).toBe(false);
    });

    it("should reject boolean values", () => {
      const result = generateFlashcardsSchema.safeParse({ text: true });

      expect(result.success).toBe(false);
    });

    it("should reject array values", () => {
      const result = generateFlashcardsSchema.safeParse({ text: ["array", "value"] });

      expect(result.success).toBe(false);
    });

    it("should reject object values", () => {
      const result = generateFlashcardsSchema.safeParse({ text: { nested: "object" } });

      expect(result.success).toBe(false);
    });
  });

  describe("Real-world scenarios", () => {
    it("should validate educational paragraph", () => {
      const text =
        "The Pythagorean theorem states that in a right-angled triangle, the square of the hypotenuse equals the sum of squares of the other two sides. Formula: a¬≤ + b¬≤ = c¬≤";
      const result = generateFlashcardsSchema.safeParse({ text });

      expect(result.success).toBe(true);
    });

    it("should validate programming concept", () => {
      const text =
        "React hooks are functions that let you use state and other React features without writing a class. Common hooks include useState, useEffect, and useContext.";
      const result = generateFlashcardsSchema.safeParse({ text });

      expect(result.success).toBe(true);
    });

    it("should validate historical fact", () => {
      const text =
        "World War II lasted from 1939 to 1945. It was the deadliest conflict in human history, involving over 30 countries and resulting in 70-85 million fatalities.";
      const result = generateFlashcardsSchema.safeParse({ text });

      expect(result.success).toBe(true);
    });

    it("should validate language learning content", () => {
      const text =
        "Common Spanish greetings:\n- Hola (Hello)\n- Buenos d√≠as (Good morning)\n- Buenas tardes (Good afternoon)\n- Buenas noches (Good evening/night)";
      const result = generateFlashcardsSchema.safeParse({ text });

      expect(result.success).toBe(true);
    });
  });
});
